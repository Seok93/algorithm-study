### 🔍 문제 링크
[Level2 **롤케이크** 문제](https://school.programmers.co.kr/learn/courses/30/lessons/132265)

### 📘 문제 설명
철수는 롤케이크를 두 조각으로 잘라서 동생과 한 조각씩 나눠 먹으려고 합니다. 이 롤케이크에는 여러가지 토핑들이 일렬로 올려져 있습니다. 철수와 동생은 롤케이크를 공평하게 나눠먹으려 하는데, 그들은 롤케이크의 크기보다 롤케이크 위에 올려진 토핑들의 종류에 더 관심이 많습니다. 그래서 잘린 조각들의 크기와 올려진 토핑의 개수에 상관없이 각 조각에 동일한 가짓수의 토핑이 올라가면 공평하게 롤케이크가 나누어진 것으로 생각합니다.

예를 들어, 롤케이크에 4가지 종류의 토핑이 올려져 있다고 합시다. 토핑들을 1, 2, 3, 4와 같이 번호로 표시했을 때, 케이크 위에 토핑들이 [1, 2, 1, 3, 1, 4, 1, 2] 순서로 올려져 있습니다. 만약 세 번째 토핑(1)과 네 번째 토핑(3) 사이를 자르면 롤케이크의 토핑은 [1, 2, 1], [3, 1, 4, 1, 2]로 나뉘게 됩니다. 철수가 [1, 2, 1]이 놓인 조각을, 동생이 [3, 1, 4, 1, 2]가 놓인 조각을 먹게 되면 철수는 두 가지 토핑(1, 2)을 맛볼 수 있지만, 동생은 네 가지 토핑(1, 2, 3, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것이 아닙니다. 만약 롤케이크의 네 번째 토핑(3)과 다섯 번째 토핑(1) 사이를 자르면 [1, 2, 1, 3], [1, 4, 1, 2]로 나뉘게 됩니다. 이 경우 철수는 세 가지 토핑(1, 2, 3)을, 동생도 세 가지 토핑(1, 2, 4)을 맛볼 수 있으므로, 이는 공평하게 나누어진 것입니다. 공평하게 롤케이크를 자르는 방법은 여러가지 일 수 있습니다. 위의 롤케이크를 [1, 2, 1, 3, 1], [4, 1, 2]으로 잘라도 공평하게 나뉩니다. 어떤 경우에는 롤케이크를 공평하게 나누지 못할 수도 있습니다.

롤케이크에 올려진 토핑들의 번호를 저장한 정수 배열 `topping`이 매개변수로 주어질 때, 롤케이크를 공평하게 자르는 방법의 수를 return 하도록 solution 함수를 완성해주세요.

### 📕 제한사항
- 1 ≤ topping의 길이 ≤ 1,000,000
  - 1 ≤ topping의 원소 ≤ 10,000

### 📙 입출력 예
|topping|result|
|:---|:---|
|[1, 2, 1, 3, 1, 4, 1, 2]|2|
|[1, 2, 3, 1, 4]|0|

### 📒 입출력 예 설명
**입출력 예 #1**  
롤케이크를 [1, 2, 1, 3], [1, 4, 1, 2] 또는 [1, 2, 1, 3, 1], [4, 1, 2]와 같이 자르면 철수와 동생은 각각 세 가지 토핑을 맛볼 수 있습니다. 이 경우 공평하게 롤케이크를 나누는 방법은 위의 두 가지만 존재합니다.

**입출력 예 #2**  
롤케이크를 공평하게 나눌 수 없습니다.

### 📔 나의 알고리즘 순서
1. 롤케이크의 토핑별 개수 정리하기
2. 토핑이 들어간 롤케이크 한 조각을 잘라서 옮기기
3. 저장된 토핑과 현재 토핑의 종류의 개수가 같은지 확인하기
4. 같으면 공평하게 분배하는 경우의 수로써 결과값 1 증가시키기
5. 롤 케이크 구간별로 전부 확인이 끝날 때까지 1~4 반복하기

### ✅ 나의 해답코드
```javascript
function solution(toppings) {
  let count = 0;

  // 1. 토핑별 개수 정리
  const toppingMap = new Map();
  toppings.forEach((topping) => {
    toppingMap.set(topping, (toppingMap.get(topping) || 0) + 1);
  });

  // 2. 각각의 구간 별로 롤케이크 구분해보기
  const store = new Set();
  while (toppings.length) {
    const t = toppings.pop();
    store.add(t);
    toppingMap.set(t, toppingMap.get(t) - 1);
    if (toppingMap.get(t) === 0) toppingMap.delete(t);
    if (store.size === toppingMap.size) count++;
  }

  return count;
}
```

### 🤔고민한점 & 💡배운점
1\) 🤔 문제를 읽고 '어라? 롤케이크 한 조각씩 옮겨서 토핑의 종류의 개수가 공평한 경우에만 카운팅 하면 되겠는걸?' 싶었다. Set을 통해 중복을 제거하면 토핑의 종류도 금방 구할 수 있겠네! 하며 신나게 풀었다.

```js
// 초반 풀이
function solution(topping) {
    let count = 0;
    
    const store = [];
    while(topping.length) {
        store.push(topping.pop());
        
        const set1 = new Set(store);
        const set2 = new Set(topping);
        if(set1.size === set2.size) count++;
    }
    
    return count;
}
```

풀이 자체는 문제가 되지 않지만, 제약 조건을 고려하지 않아서 테스트 케이스 검사에서 시간 초과가 발생했다. Set이 만들어지면 연산이 빨라지지만, Set을 만들기 위해 순차적으로 넣어주는 과정은 토핑의 개수에 비례하는 작업이 되고, 위의 풀이는 결과적으로 O(N^2)이 되는 풀이가 된다. 때문에 제약사항 100만개의 경우를 충족할 수 없다.

2\) 🤔 시간초과가 발생한 후, 제한사항부터 다시 분석을 시작했다. 제한사항을 보면 `topping`의 개수가 최대 100만개가 된다. 보통 100만개라는 케이스를 가지고 있으면, 시간 복잡도는 O(NlogN) 안으로 들어가야 했다. 토핑의 사이를 순차적으로 접근해야하니 이 부분이 N이 될테고, 그럼 토핑의 종류를 비교하는 부분이 logN 이하의 연산을 진행해야 했다. 어떻게 하면 연산량을 줄일 수 있을까 고민이 되었다. 정렬할 수 없으니 이분 탐색은 안되고, 투포인터처럼 좌표를 이동하면서 일부분만 확인할 수 있을까도 생각해봤다. 그러다 접근 효율을 높이기 위해 해쉬 테이블처럼 직접적으로 접근하여 관리할 수 있는 방법이 있을까란 생각이 들었다.

결과적으로 토핑의 종류별로 개수를 누적하고, 롤케이크를 한조각씩 옮길 때 이를 차감하는 방식으로 원본 롤 케이크의 토핑 종류의 개수를 특정하게 되었다. 이를 통해 토핑의 개수를 거의 O(1)에 가깝게 관리할 수 있게 되었고 문제를 통과할 수 있었다.


