### 🔍 문제 링크
[Level2 **두 큐 합 같게 만들기** 문제](https://school.programmers.co.kr/learn/courses/30/lessons/118667#)

### 📘 문제 설명
길이가 같은 두 개의 큐가 주어집니다. 하나의 큐를 골라 원소를 추출(pop)하고, 추출된 원소를 다른 큐에 집어넣는(insert) 작업을 통해 각 큐의 원소 합이 같도록 만들려고 합니다. 이때 필요한 작업의 최소 횟수를 구하고자 합니다. 한 번의 pop과 한 번의 insert를 합쳐서 작업을 1회 수행한 것으로 간주합니다.

큐는 먼저 집어넣은 원소가 먼저 나오는 구조입니다. 이 문제에서는 큐를 배열로 표현하며, 원소가 배열 앞쪽에 있을수록 먼저 집어넣은 원소임을 의미합니다. 즉, pop을 하면 배열의 첫 번째 원소가 추출되며, insert를 하면 배열의 끝에 원소가 추가됩니다. 예를 들어 큐 `[1, 2, 3, 4]`가 주어졌을 때, pop을 하면 맨 앞에 있는 원소 1이 추출되어 `[2, 3, 4]`가 되며, 이어서 5를 insert하면 `[2, 3, 4, 5]`가 됩니다.

다음은 두 큐를 나타내는 예시입니다.

```
queue1 = [3, 2, 7, 2]
queue2 = [4, 6, 5, 1]
```
두 큐에 담긴 모든 원소의 합은 30입니다. 따라서, 각 큐의 합을 15로 만들어야 합니다. 예를 들어, 다음과 같이 2가지 방법이 있습니다.

queue2의 4, 6, 5를 순서대로 추출하여 queue1에 추가한 뒤, queue1의 3, 2, 7, 2를 순서대로 추출하여 queue2에 추가합니다. 그 결과 queue1은 [4, 6, 5], queue2는 [1, 3, 2, 7, 2]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 7번 수행합니다.
queue1에서 3을 추출하여 queue2에 추가합니다. 그리고 queue2에서 4를 추출하여 queue1에 추가합니다. 그 결과 queue1은 [2, 7, 2, 4], queue2는 [6, 5, 1, 3]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 2번만 수행하며, 이보다 적은 횟수로 목표를 달성할 수 없습니다.
따라서 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수는 2입니다.

길이가 같은 두 개의 큐를 나타내는 정수 배열 `queue1`, `queue2`가 매개변수로 주어집니다. 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수를 return 하도록 solution 함수를 완성해주세요. 단, 어떤 방법으로도 각 큐의 원소 합을 같게 만들 수 없는 경우, -1을 return 해주세요.

### 📕 제한사항
- 1 ≤ `queue1`의 길이 = `queue2`의 길이 ≤ 300,000
- 1 ≤ `queue1`의 원소, `queue2`의 원소 ≤ 109
- 주의: 언어에 따라 합 계산 과정 중 산술 오버플로우 발생 가능성이 있으므로 long type 고려가 필요합니다.


### 📙 입출력 예
|queue1|queue2|result|
|:---|:---|:---|
|[3, 2, 7, 2]|[4, 6, 5, 1]|2|
|[1, 2, 1, 2]|[1, 10, 1, 2]|7|
|[1, 1]|[1, 5]|-1|

### 📒 입출력 예 설명
**입출력 예 #1**  
문제 예시와 같습니다.

**입출력 예 #2**  
두 큐에 담긴 모든 원소의 합은 20입니다. 따라서, 각 큐의 합을 10으로 만들어야 합니다. queue2에서 1, 10을 순서대로 추출하여 queue1에 추가하고, queue1에서 1, 2, 1, 2와 1(queue2으로부터 받은 원소)을 순서대로 추출하여 queue2에 추가합니다. 그 결과 queue1은 [10], queue2는 [1, 2, 1, 2, 1, 2, 1]가 되며, 각 큐의 원소 합은 10으로 같습니다. 이때 작업 횟수는 7회이며, 이보다 적은 횟수로 목표를 달성하는 방법은 없습니다. 따라서 7를 return 합니다.

**입출력 예 #3**  
어떤 방법을 쓰더라도 각 큐의 원소 합을 같게 만들 수 없습니다. 따라서 -1을 return 합니다.

### 📔 나의 알고리즘 순서
1) 큐의 합을 구하여 목표값을 구한다. → 짝수가 아니라면 2개의 큐가 같아질 수 없다.
2) 더블 포인터를 이용하여, queue1이 목표값보다 작으면 뒤쪽 포인터를, 목표값보다 크면 앞쪽 포인터 이동시키면서 큐의 총합을 산출하며, 최대 두 큐의 원소의 개수 * 2만큼 순회하고 안되면 -1를 반환한다.

### ✅ 나의 해답코드
```javascript
function solution(queue1, queue2) {
  const getTotalValue = (queue) => queue.reduce((sum, v) => sum + v, 0);

  let sum1 = getTotalValue(queue1);
  let sum2 = getTotalValue(queue2);
  if (sum1 === sum2) return 0;

  const total = sum1 + sum2;
  if (total % 2 !== 0) return -1;

  const target = total / 2;
  const round = (queue1.length + queue2.length) * 2;

  let lPointer = 0;
  let rPointer = queue1.length;
  const q = [...queue1, ...queue2];
  for (let i = 0; i < round; i++) {
    if (target === sum1) return i;
    sum1 = sum1 > target ? sum1 - q[lPointer++ % q.length] : sum1 + q[rPointer++ % q.length];
  }
  return -1;
}

```


### 📝고민한점 & 💡배운점
1\) 🤔 처음에는 어떻게 해야 모든 경우의 수를 구할 수 있을까 고민했다. 최소 이동으로 목표값을 만들어야 하는데, 최소 이동이니 BFS로 구해야하나 싶었다. 하지만 데이터를 pop하거나 unshift하는 과정에서 매번 2의 배수로 경우의 수가 증가하며, queue의 길이가 300,000이라는 점을 감안할 때 경우의 수가 기하급수적으로 올라갈 것이라 판단하고 좋은 방법이 아니라고 생각했다.

2\) 🤔 queue1과 queue2를 그려서 데이터가 나가고 들어갈 때 어떤 변화가 일어나는지 그려보았다. 이때 큐의 특성상 데이터가 나가고 들어갈 때 순서가 있기 때문에, 결과적으로 queue1과 queue2도 정해진 순서대로 데이터들이 이동한다는 점을 알게 되었다. 때문에 합으로 만들 수 있는 모든 경우의 수는 queue1과 queue2의 모든 원소의 수의 2배가 필요하다.

3\) 🤔 합산을 통해 결과를 얻은 결과 30개의 케이스중 시간초과가 발생하는 케이스가 4개 있었다. 그래서 시간복잡도를 올리는 이유를 생각하던 중 Array.prototype.shift 메서드가 배열의 삭제와 같고, 이는 최악의 경우 O(n)의 시간복잡도를 가진다는 것을 알게 되었다. 떼문에 shift 메서드를 이용하지 않은 상태로 실질적인 데이터의 이동을 표현 해야했다.

이때 사용했던 방법이 queue1을 기준으로 시작과 끝을 가리키는 포인터를 각각 준비하여 상황에 따라 포인터를 이동하면서 총합의 값을 산출하는 방법이었다. 정해진 횟수 내에서 목표값을 달성하나 큐의 포인터를 이동하면서 비교해보고 만들 수 있으면 이동 횟수를 반환, 안된다면 -1을 반환하여 문제를 풀이하였다.

![](./img/더블포인터를%20이용한%20큐%20연산.png)

### 🔍참고 내용
https://koguri.tistory.com/108