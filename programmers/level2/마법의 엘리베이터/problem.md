### 🔍 문제 링크
[Level2 **마법의 엘리베이터** 문제](https://school.programmers.co.kr/learn/courses/30/lessons/148653)

### 📘 문제 설명
마법의 세계에 사는 민수는 아주 높은 탑에 살고 있습니다. 탑이 너무 높아서 걸어 다니기 힘든 민수는 마법의 엘리베이터를 만들었습니다. 마법의 엘리베이터의 버튼은 특별합니다. 마법의 엘리베이터에는 -1, +1, -10, +10, -100, +100 등과 같이 절댓값이 10c (c ≥ 0 인 정수) 형태인 정수들이 적힌 버튼이 있습니다. 마법의 엘리베이터의 버튼을 누르면 현재 층 수에 버튼에 적혀 있는 값을 더한 층으로 이동하게 됩니다. 단, 엘리베이터가 위치해 있는 층과 버튼의 값을 더한 결과가 0보다 작으면 엘리베이터는 움직이지 않습니다. 민수의 세계에서는 0층이 가장 아래층이며 엘리베이터는 현재 민수가 있는 층에 있습니다.

마법의 엘리베이터를 움직이기 위해서 버튼 한 번당 마법의 돌 한 개를 사용하게 됩니다.예를 들어, 16층에 있는 민수가 0층으로 가려면 -1이 적힌 버튼을 6번, -10이 적힌 버튼을 1번 눌러 마법의 돌 7개를 소모하여 0층으로 갈 수 있습니다. 하지만, +1이 적힌 버튼을 4번, -10이 적힌 버튼 2번을 누르면 마법의 돌 6개를 소모하여 0층으로 갈 수 있습니다.

마법의 돌을 아끼기 위해 민수는 항상 최소한의 버튼을 눌러서 이동하려고 합니다. 민수가 어떤 층에서 엘리베이터를 타고 0층으로 내려가는데 필요한 마법의 돌의 최소 개수를 알고 싶습니다. 민수와 마법의 엘리베이터가 있는 층을 나타내는 정수 `storey`가 주어졌을 때, 0층으로 가기 위해 필요한 마법의 돌의 최소값을 return 하도록 solution 함수를 완성하세요.

### 📕 제한사항
- 1 ≤ `storey` ≤ 100,000,000


### 📙 입출력 예
|storey|result|
|:---|:---|
|16|6|
|2554|16|

### 📒 입출력 예 설명
**입출력 예 #1**  
문제 예시와 같습니다.

입출력 예 #2

-1, +100이 적힌 버튼을 4번, +10이 적힌 버튼을 5번, -1000이 적힌 버튼을 3번 누르면 0층에 도착 할 수 있습니다. 그러므로 16을 return 합니다.

### 📔 나의 알고리즘 순서


### ✅ 나의 해답코드
```javascript
function solution(storey) {
  let count = 0;
  while (storey > 0) {
    const value = storey % 10;
    storey = (storey - value) / 10;

    if (value < 5) {
      count += value;
    } else if (value > 5) {
      storey += 1;
      count += 10 - value;
    } else {
      const next = storey % 10;
      if (next >= 5) {
        storey += 1;
        count += 10 - value;
      } else {
        count += value;
      }
    }
  }
  return count;
}
```

### ✨ 깔끔한 해답코드
```javascript
function solution(storey) {
    if (storey < 5) return storey;
    const r = storey % 10;
    const m = (storey - r) / 10;
    return Math.min(r + solution(m), 10 - r + solution(m + 1));
}
```

### 🤔고민한점 & 💡배운점
1\) 🤔 문제를 읽고, 10으로 나눠서 나온 나머지를 일정한 규칙으로 처리해야 한다고 생각했다. 그래서 규칙을 생각해보고 아래와 같은 결론에 도달했다.

- 5보다 작으면 숫자를 내려주는 것이, 버튼을 더 적게 누를 수 있다. 
- 5보다 크면 숫자를 올려주는 것이, 버튼을 더 적게 누를 수 있다. (단, 다음 자릿수에 +1을 더해줘야 한다.)

문제는 만약 숫자가 5라면, 더하기와 빼기 중 어느 것이 버튼을 더 적게 누를 수 있을까 고민해야 했다. 단순하게 생각하면, 숫자를 빼는 것이 다음 자릿수에 +1을 안해줘도 되어서 더 빠른 방법 같지만, 다음 자릿수에 +1을 해줌으로써 연산 방법이 변경될 수 있다는 점을 감안한다면 숫자 5는 다음 자릿수의 크기를 통해 더해야할지, 빼야할지를 정해줘야 했다. 그래서 나온 결론은 다음과 같다.

- 5라면, 다음 자릿수를 확인해야 한다. 
  - 다음 자릿수가 5와 같거나 크면, 숫자를 올려주는 것이 버튼을 더 적게 누를 수 있다.
  - 다음 자릿수가 5보다 작으면, 숫자를 내려주는 것이 버튼을 더 적게 누를 수 있다.

2\)💡문제를 통과한 후 다른 사람의 해답 코드를 확인하던 중 가독성이 좋은 깔끔한 해답 코드를 발견했다. 바로 재귀적으로 구현된 DFS 알고리즘을 사용하는 것이다. 물론 연산 효율면에서는 내가 생각한 로직이 더 좋지만, 가독성에서는 깔끔한 해답 코드가 좋다.

내가 생각한 로직보다 더 단순하게 나머지 숫자를 내려주는 것이 좋인지, 올리는 것이 좋은지 2가지 선택지를 통해 DFS 연산을 수행하여 최솟값을 만드는 방법이다.