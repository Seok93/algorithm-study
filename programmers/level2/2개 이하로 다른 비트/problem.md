### 🔍 문제 링크
[Level2 **2개 이하로 다른 비트** 문제](https://school.programmers.co.kr/learn/courses/30/lessons/77885)

### 📘 문제 설명
양의 정수 `x`에 대한 함수 `f(x)`를 다음과 같이 정의합니다.

- `x`보다 크고 `x`와 비트가 1~2개 다른 수들 중에서 제일 작은 수

예를 들어,
- `f(2) = 3`입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

|수|비트|다른 비트의 개수|
|:---|:---|:---|
|2|000...0010||	
|3|000...0011|1|

- `f(7) = 11`입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.
 
|수|비트|다른 비트의 개수|
|:---|:---|:---|
|7|000...0111||
|8|000...1000|4|
|9|000...1001|3|
|10|000...1010|3|
|11|000...1011|2|

정수들이 담긴 배열 `numbers`가 매개변수로 주어집니다. `numbers`의 모든 수들에 대하여 각 수의 `f`값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

### 📕 제한사항
- 1 ≤ `numbers`의 길이 ≤ 100,000
- 0 ≤ `numbers`의 모든 수 ≤ 10^15

### 📙 입출력 예
|numbers|result|
|:---|:---|
|[2,7]|[3,11]|

### 📔 나의 알고리즘 순서
1. numbers에서 숫자를 하나 가져와서 2진수로 변환한다.
2. 일의 자리부터 하나씩 올라가며, 비트중 0 ⇒ 1 변경이 가능한 자리를 찾는다.
3. 변경이 가능한 자리의 비트를 0을 1로 바꾸고, 이전 자리수를 1에서 0으로 치환해준다.
4. 치환한 결과를 10진수 값으로 변경하여 반환한다.
5. numbers의 모든 숫자에 대해 검사가 끝날 때까지 반복한다.

### ✅ 나의 해답코드
```javascript
function solution(numbers) {
  return numbers.map((number) => {
    const binary = ['0', ...number.toString(2)];
    for (let i = binary.length; i >= 0; i--) {
      if (binary[i] === '0') {
        binary[i] = '1';
        if (binary.length > i + 1) binary[i + 1] = '0';
        break;
      }
    }
    return parseInt(binary.join(''), 2);
  });
}
```

### 🤔고민한점 & 💡배운점
1\) 🤔 제한 사항에 적혀있는 numbers의 길이와 각 요소의 크기를 고려했을 때, 기준 숫자(`number`)를 기준으로 1씩 더하며, 이진수 비트의 차이가 2개 이하인 최소 값을 찾는 일반적인 방법은 불가능하다고 생각했다.

그래서 기준 숫자를 이진수로 치환하여, 비트가 2개 이하로 차이나는 제일 가까운 큰 수를 만족할 때 어떤 규칙이 생기나 살펴보고자 경우의 수를 적어보았다.

```
1  ⇒ 0001
2  ⇒ 0010
3  ⇒ 0011
4  ⇒ 0100
5  ⇒ 0101
6  ⇒ 0110
7  ⇒ 0111 
8  ⇒ 1000
9  ⇒ 1001
10 ⇒ 1010
11 ⇒ 1011
12 ⇒ 1100
13 ⇒ 1101
14 ⇒ 1110
15 ⇒ 1111
```

하나씩 치환하여 비트가 2개 이하로 차이나면서 제일 가까운 수의 규칙을 찾아보니, 기준 숫자의 이진수를 기준으로 일의 자리부터 순차적으로 자릿수를 옮기며 0비트가 나오는 자릿수를 찾고, 0을 1로 치환하고 바로 이전 자릿수를 1에서 0으로 치환하면 제일 가까우면서 비트가 2개 이하로 차이나는 수임을 알게 되었다. 이를 바탕으로 문제를 해결했습니다.